from .utils import *


class DoubletInfo:
    """
    Holds information about doublet for a given spacepoint when it is considered as the middle spacepoint.
    Output of the doubletCounting step write there
    """

    def __init__(self, nbSpacepoints):
        # number of inner doublet (other spacepoint has a smaller radius)
        self.nInner = np.zeros(nbSpacepoints, dtype=np.int64)
        # number of outer doublet (other spacepoint has a bigger radius)
        self.nOuter = np.zeros(nbSpacepoints, dtype=np.int64)
        # True if at least one inner and one outer doublet, false otherwise
        self.good = np.zeros(nbSpacepoints, dtype=np.bool8)


class DoubletStorage:
    """
    Store the doublets generated by the algorithm for a given event
    """

    def __init__(self):
        self.nO = 0
        self.nI = 0
        self.nItems = 0
        self.spmIdx = []
        self.innerStart = []
        self.outerStart = []
        self.inner = []
        self.outer = []


class SpacepointLayerRange:
    """
    Class holding the startIndex and endIndex of each layer for each phi slice in the object SpacepointStorage
    """

    def __init__(self, nLayers):
        # starting idx of each layer for a given phi slice
        self.layerBegin = np.zeros(nLayers, dtype=np.int64)
        # one element after the last idx
        self.layerEnd = np.zeros(nLayers, dtype=np.int64)


class SpacepointStorage:
    """
    Class holding all the spacepoints and informations about the phi slices
    """

    def __init__(self, spacepoints, config):
        """
        Init the spacepoints storage. Spacepoints are expected to be given as a pandas dataframe.
        Only spacepoints from a single event and modules/layers according to the DetectorModel should be given
        """

        # Contains the type of the spacepoints (Pixel = true, SCT = False)
        self.type = np.zeros(spacepoints.shape[0], dtype=np.bool8)
        # Contains the z coordinate of the spacepoints
        self.z = np.zeros(spacepoints.shape[0])
        # Contains the r coordinate of the spacepoints
        self.r = np.zeros(spacepoints.shape[0])
        # Contains the x coordinate of the spacepoints
        self.x = np.zeros(spacepoints.shape[0])
        # Contains the y coordinate of the spacepoints
        self.y = np.zeros(spacepoints.shape[0])

        # id given to a spacepoint, used only for computing efficiency between the standard and modified seeding,
        # it's not necessary for the seeding
        self.idsp = np.zeros(spacepoints.shape[0], dtype=np.int64)

        # fill these arrays, not implemented
        self.covZ = np.ones(spacepoints.shape[0]) * 100
        self.covR = np.ones(spacepoints.shape[0]) * 100

        # start/end index of each phi slice/layer
        self.phiSlices = [SpacepointLayerRange(config.nLayers) for _ in range(config.nPhiSlices)]

        spacepoints['phi'] = calc_phi(spacepoints['x'], spacepoints['y'])
        spacepoints['bin_phi'] = scale_phi(spacepoints['phi'], config.nPhiSlices)
        spacepoints['r'] = calc_r(spacepoints['x'], spacepoints['y'])

        self.module_ids = np.zeros(spacepoints.shape[0])

        # define the position of a given detector layer
        layNoToIdx = {2: 0, 4: 1, 6: 2, 8: 3}
        volToOffset = {8: 0, 13: 4, 17: 8}
        crtIdx = 0
        for (sliceid, volid, layid), df in spacepoints.groupby(['bin_phi', 'volume_id', 'layer_id'], sort=False):
            layIdx = volToOffset[volid] + layNoToIdx[layid]
            nbHits = df.shape[0]
            self.phiSlices[sliceid].layerBegin[layIdx] = crtIdx
            nextIdx = crtIdx + nbHits
            self.phiSlices[sliceid].layerEnd[layIdx] = nextIdx

            pixel = df['volume_id'] == 8
            self.type[crtIdx:nextIdx] = pixel.values

            self.x[crtIdx:nextIdx] = df['x'].values
            self.y[crtIdx:nextIdx] = df['y'].values
            self.z[crtIdx:nextIdx] = df['z'].values
            self.r[crtIdx:nextIdx] = df['r'].values
            self.idsp[crtIdx:nextIdx] = df['hit_id'].values
            self.module_ids[crtIdx:nextIdx] = df['module_id'].values
            crtIdx = nextIdx
