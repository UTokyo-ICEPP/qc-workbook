
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>【課題】量子相関を調べる &#8212; 量子コンピューティング・ワークブック</title>
    
  <link rel="stylesheet" href="_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="単純な量子回路をゼロから書く" href="circuit_from_scratch.html" />
    <link rel="prev" title="CHSH不等式の破れを確認する" href="chsh_inequality.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/favicon.ico" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">量子コンピューティング・ワークブック</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="welcome.html">
   量子コンピューティング・ワークブックへようこそ！
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  量子コンピュータに触れる
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="chsh_inequality.html">
   CHSH不等式の破れを確認する
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   【課題】量子相関を調べる
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  超並列計算機としての量子コンピュータ
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="circuit_from_scratch.html">
   単純な量子回路をゼロから書く
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="extreme_simd.html">
   4兆通りの足し算を同時に行う
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="quantum_computation.html">
   【課題】量子計算
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  量子ダイナミクスシミュレーション
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="dynamics_simulation.html">
   物理系を表現する
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="more_dynamics.html">
   【課題】量子ダイナミクスシミュレーション・続
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  ショアのアルゴリズム
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="shor.html">
   素因数分解アルゴリズムを学習する
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="spectrum_estimation.html">
   【課題】位相推定によるスペクトル分解
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  グローバーのアルゴリズム
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="grover.html">
   データベース検索を行う
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="amplitude_amplification.html">
   【課題】振幅増幅を確認する
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  変分法と変分量子固有値ソルバー
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="vqe.html">
   変分法と変分量子固有値ソルバー法を学習する
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="vqe_tracking.html">
   【課題】高エネルギー実験で生成された荷電粒子の飛跡を見つける
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  量子・古典ハイブリッド機械学習
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="vqc_machine_learning.html">
   量子機械学習を使った新しい素粒子現象の探索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="vqc_machine_learning.html#roc">
   ROC曲線を描いてみる
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="qkc_machine_learning.html">
   【課題】量子カーネルを使った新現象の分類
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  補足
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="prerequisites.html">
   実習の準備
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="numerics.html">
   数値表現
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="bibliography.html">
   参考文献
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/nonlocal_correlations.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/UTokyo-ICEPP/qc-workbook"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/UTokyo-ICEPP/qc-workbook/issues/new?title=Issue%20on%20page%20%2Fnonlocal_correlations.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/UTokyo-ICEPP/qc-workbook/master?urlpath=lab/tree/nonlocal_correlations.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#qc">
   QCシミュレータの使い方
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id4">
   測定基底の変換
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id6">
   観測量の期待値とその計算法
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#chsh">
   CHSH不等式を見直す
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   問題: ベル状態と可分状態の違い
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sigma">
     一般の
     <span class="math notranslate nohighlight">
      \(\sigma\)
     </span>
     演算子の期待値
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id10">
     問題
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="id1">
<h1>【課題】量子相関を調べる<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>第一回の実習ではCHSH不等式の破れを調べるために、2つの量子ビットの相関関数<span class="math notranslate nohighlight">\(C^{i} \, (i=0,1,2,3)\)</span>という量を量子コンピュータを使って計算しました。この課題では、この量をもう少し細かく調べてみましょう。</p>
<div class="contents local topic" id="id2">
<p class="topic-title">目次</p>
<ul class="simple">
<li><p><a class="reference internal" href="#qc" id="id11">QCシミュレータの使い方</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id12">測定基底の変換</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id13">観測量の期待値とその計算法</a></p></li>
<li><p><a class="reference internal" href="#chsh" id="id14">CHSH不等式を見直す</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id15">問題: ベル状態と可分状態の違い</a></p>
<ul>
<li><p><a class="reference internal" href="#sigma" id="id16">一般の<span class="math notranslate nohighlight">\(\sigma\)</span>演算子の期待値</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id17">問題</a></p></li>
</ul>
</li>
</ul>
</div>
<p><span class="math notranslate nohighlight">\(\newcommand{\ket}[1]{|#1\rangle}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\bra}[1]{\langle#1|}\)</span></p>
<div class="section" id="qc">
<h2><a class="toc-backref" href="#id11">QCシミュレータの使い方</a><a class="headerlink" href="#qc" title="Permalink to this headline">¶</a></h2>
<p>実習で見たように、QCで実現される量子状態は、量子力学の公理に基づいて理論的に計算・予測できます。そこで用いられる数学的操作も単なる足し算や掛け算（線形演算）なので、実はQCの量子状態は（古典）計算機で比較的簡単に計算できます。当然のことですが、QCは何も魔法のブラックボックスというわけではありません。</p>
<p>ただし、古典計算機で量子状態を再現するためには、特殊な場合を除いて、量子ビット数の指数関数的な量のメモリが必要になります。これも前半で見たように、<span class="math notranslate nohighlight">\(n\)</span>量子ビットあれば、系の自由度（degrees of freedom / dof: 実数自由パラメータの数）は<span class="math notranslate nohighlight">\(2^{n+1} - 2\)</span>ですので、例えば各自由度を64ビット（＝8バイト）の浮動小数点で表現するとしたら、必要なメモリは(-2を無視して)</p>
<div class="math notranslate nohighlight">
\[
2^3\, \mathrm{(bytes / dof)} \times 2^{n+1}\, \mathrm{(dof)} = 2^{n+4}\, \mathrm{(bytes)}
\]</div>
<p>なので、<span class="math notranslate nohighlight">\(n=16\)</span>で1 MiB、<span class="math notranslate nohighlight">\(n=26\)</span>で1 GiB、<span class="math notranslate nohighlight">\(n=36\)</span>で1 TiBです。現在の計算機では、ハイエンドワークステーションでRAMが<span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> TiB、スパコン「富岳」で5 PB (~2<sup>52</sup> bytes)なのに対し、QCではすでに<span class="math notranslate nohighlight">\(n=65\)</span>のものが存在するので、既に古典計算機でまともにシミュレートできない機械が存在していることになります。</p>
<p>しかし、逆に言うと、<span class="math notranslate nohighlight">\(n \sim 30\)</span>程度までの回路であれば、ある程度のスペックを持った計算機で厳密にシミュレートできるということが言えます。じっさい世の中には<a class="reference external" href="https://quantiki.org/wiki/list-qc-simulators">数多くの</a>シミュレータが存在します。Qiskitにも様々な高機能シミュレータが同梱されています。</p>
<p>シミュレーションはローカル（手元のPythonを動かしているコンピュータ）で実行できるので、ジョブを投げて結果を待つ時間が省けます。この課題ではたくさんの細かい量子計算をするので、実機を使わず、<code class="docutils literal notranslate"><span class="pre">qasm_simulator</span></code>というQiskitに含まれるシミュレータを利用します。</p>
<p>Qiskitのシミュレータには<code class="docutils literal notranslate"><span class="pre">Aer</span></code>というオブジェクトからアクセスします。<code class="docutils literal notranslate"><span class="pre">Aer</span></code>は実習で登場した<code class="docutils literal notranslate"><span class="pre">IBMQ</span></code>と同様の構造をしており、複数のシミュレータをバックエンドとして管理しています。そのうちの<code class="docutils literal notranslate"><span class="pre">qasm_simulator</span></code>を取り出します。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># まずは全てインポート</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">Bounds</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">execute</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;notebook ready&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>notebook ready
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">simulator</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>qasm_simulator
</pre></div>
</div>
</div>
</div>
<p>実習の内容を再現してみましょう。</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;circuit</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ic</span><span class="p">))</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>

<span class="n">circuits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circuits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circuits</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="mf">3.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">circuits</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circuits</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="n">circuits</span><span class="p">:</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
    
<span class="n">shots</span> <span class="o">=</span> <span class="mi">10000</span>
    
<span class="n">sim_job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">simulator</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>

<span class="n">sim_result</span> <span class="o">=</span> <span class="n">sim_job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="n">C</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">circuit</span> <span class="ow">in</span> <span class="n">circuits</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">sim_result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">()</span>
    <span class="n">plot_histogram</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
    
    <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;00&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;01&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;10&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="n">shots</span><span class="p">)</span>
    
<span class="n">S</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">C</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S =&#39;</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>上のように、<code class="docutils literal notranslate"><span class="pre">qasm_simulator</span></code>は実機と同様に<code class="docutils literal notranslate"><span class="pre">execute</span></code>関数で実行でき、ヒストグラムデータを返します。実機ではショット数に制限がありますが、シミュレータにはありません。ただしショット数が多いほど、当然実行に時間がかかります。といってもこの程度の回路であれば常識的なショット数ならほぼ瞬間的にジョブの実行が終わるので、上の例では実習で使った<code class="docutils literal notranslate"><span class="pre">job_monitor()</span></code>関数を使用していません。また、シミュレータにはノイズがない<a class="footnote-reference brackets" href="#simulator-noise" id="id3">1</a>ので、<span class="math notranslate nohighlight">\(S\)</span>の計算結果が統計誤差の範囲内で理論値と一致していることが見て取れます。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id12">測定基底の変換</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>さて、おさらいをすると、上の<span class="math notranslate nohighlight">\(C^{0,1,2,3}\)</span>を計算する4つの回路は以下のようなものでした。</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="_images/nonlocal_correlations_8_0.png" src="_images/nonlocal_correlations_8_0.png" />
<img alt="_images/nonlocal_correlations_8_1.png" src="_images/nonlocal_correlations_8_1.png" />
<img alt="_images/nonlocal_correlations_8_2.png" src="_images/nonlocal_correlations_8_2.png" />
<img alt="_images/nonlocal_correlations_8_3.png" src="_images/nonlocal_correlations_8_3.png" />
</div>
</div>
<p>ベル状態を作るところまですべての回路で共通で、その後それぞれ異なる角度の<span class="math notranslate nohighlight">\(R_y\)</span>ゲートをかけています。実習では深く立ち入りませんでしたが、この<span class="math notranslate nohighlight">\(R_y\)</span>ゲートはベル状態を<span class="math notranslate nohighlight">\(\{\ket{0}, \ket{1}\}\)</span>とは異なる基底で測定するために置かれています。どういうことか、以下で説明します。</p>
<p>ここまで「測定」とはレジスタの量子状態<span class="math notranslate nohighlight">\(\sum_{j=0}^{2^n-1} c_j \ket{j}\)</span>からビット列<span class="math notranslate nohighlight">\(j\)</span>を確率<span class="math notranslate nohighlight">\(|c_j|^2\)</span>で得る行為である、と説明してきました。しかし、本来「測定」はもっと一般的な概念です。それを理解するために、まず、量子力学的には計算基底状態<span class="math notranslate nohighlight">\(\ket{j}\)</span>は何ら特別な状態ではないということを理解しておきましょう。</p>
<p>例えば1量子ビットにおいて、計算基底状態は<span class="math notranslate nohighlight">\(\ket{0}\)</span>と<span class="math notranslate nohighlight">\(\ket{1}\)</span>ですが、以下のような状態<span class="math notranslate nohighlight">\(\ket{\theta}\)</span>と<span class="math notranslate nohighlight">\(\ket{\theta + \pi}\)</span>を考えます。</p>
<div class="math notranslate nohighlight" id="equation-theta-ket-def">
<span class="eqno">(1)<a class="headerlink" href="#equation-theta-ket-def" title="Permalink to this equation">¶</a></span>\[\begin{split}\ket{\theta} := R_y(\theta)\ket{0} = \cos\frac{\theta}{2}\ket{0} + \sin\frac{\theta}{2}\ket{1} \\
\ket{\theta + \pi} := R_y(\theta)\ket{1} = -\sin\frac{\theta}{2}\ket{0} + \cos\frac{\theta}{2}\ket{1}\end{split}\]</div>
<p>すると、</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\ket{0} = \cos\frac{\theta}{2}\ket{\theta} - \sin\frac{\theta}{2}\ket{\theta + \pi} \\
\ket{1} = \sin\frac{\theta}{2}\ket{\theta} + \cos\frac{\theta}{2}\ket{\theta + \pi},
\end{split}\]</div>
<p>つまり、計算基底状態が<span class="math notranslate nohighlight">\(\ket{\theta}\)</span>と<span class="math notranslate nohighlight">\(\ket{\theta + \pi}\)</span>の重ね合わせとして表現できます。量子ビットの任意の状態は<span class="math notranslate nohighlight">\(\ket{0}\)</span>と<span class="math notranslate nohighlight">\(\ket{1}\)</span>の重ね合わせで表現できるので、<span class="math notranslate nohighlight">\(\ket{\theta}\)</span>と<span class="math notranslate nohighlight">\(\ket{\theta + \pi}\)</span>の重ね合わせでも表現できるということになります。そのようなときは<span class="math notranslate nohighlight">\(\ket{\theta}\)</span>と<span class="math notranslate nohighlight">\(\ket{\theta + \pi}\)</span>を基底として状態を表しているわけです。</p>
<p>一般に、量子力学的には、2つの異なる状態<span class="math notranslate nohighlight">\(\ket{a} \nsim \ket{b}\)</span>を考えれば、それらの重ね合わせで量子ビットの任意の状態が表現できます。そして、<span class="math notranslate nohighlight">\(\ket{a}\)</span>と<span class="math notranslate nohighlight">\(\ket{b}\)</span>が直交する<a class="footnote-reference brackets" href="#orthogonal" id="id5">2</a>ときに状態<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>が</p>
<div class="math notranslate nohighlight">
\[
\ket{\psi} = \alpha \ket{a} + \beta \ket{b}
\]</div>
<p>と表現されるならば、「基底<span class="math notranslate nohighlight">\(\ket{a}\)</span>と<span class="math notranslate nohighlight">\(\ket{b}\)</span>についての測定」という操作を考えることができます。<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>に対してそのような測定をすると、状態<span class="math notranslate nohighlight">\(\ket{a}\)</span>が確率<span class="math notranslate nohighlight">\(|\alpha|^2\)</span>で、状態<span class="math notranslate nohighlight">\(\ket{b}\)</span>が確率<span class="math notranslate nohighlight">\(|\beta|^2\)</span>で得られます。</p>
<p>量子計算においても、アルゴリズムの一部として、計算の結果実現した状態を特定の基底で測定するということが多々あります。ところが、ここで若干問題があります。量子コンピュータは実装上、計算基底でしか測定ができないのです。量子力学の理論的には特別でない<span class="math notranslate nohighlight">\(\ket{0}\)</span>と<span class="math notranslate nohighlight">\(\ket{1}\)</span>ですが、量子コンピュータという実態にとっては具体的な対応物があるのです。</p>
<p>そこで、量子計算では、状態を任意の基底で測定することを諦め、反対に状態を変化させてしまいます。例えば、本当は上の<span class="math notranslate nohighlight">\(\ket{\theta}\)</span>と<span class="math notranslate nohighlight">\(\ket{\theta + \pi}\)</span>という基底で量子ビットの状態<span class="math notranslate nohighlight">\(\ket{\psi} = \alpha \ket{\theta} + \beta \ket{\theta + \pi}\)</span>を測定したいとします。しかし計算基底でしか測定ができないので、代わりに<span class="math notranslate nohighlight">\(R_y(-\theta)\)</span>を<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>にかけます。すると式<a class="reference internal" href="#equation-theta-ket-def">(1)</a>から</p>
<div class="math notranslate nohighlight">
\[\begin{split}
R_y(-\theta)\ket{\theta} = \ket{0} \\
R_y(-\theta)\ket{\theta + \pi} = \ket{1}
\end{split}\]</div>
<p>なので、</p>
<div class="math notranslate nohighlight">
\[
R_y(-\theta)\ket{\psi} = \alpha \ket{0} + \beta \ket{1}
\]</div>
<p>が得られます。この<span class="math notranslate nohighlight">\(R_y(-\theta)\ket{\psi}\)</span>を計算基底で測定した結果は、<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>を<span class="math notranslate nohighlight">\(\ket{\theta}, \ket{\theta + \pi}\)</span>基底で測定した結果と等価です。</p>
<p>このように、測定を行いたい基底（ここでは<span class="math notranslate nohighlight">\(\ket{\theta}, \ket{\theta + \pi}\)</span>）を<span class="math notranslate nohighlight">\(\ket{0}, \ket{1}\)</span>から得るための変換ゲート（<span class="math notranslate nohighlight">\(R_y(\theta)\)</span>）の逆変換を測定したい状態にかけることで、計算基底での測定で求める結果を得ることができます。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id13">観測量の期待値とその計算法</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>課題の説明に入る前に、さらに話が込み入ってきますが、量子計算でも多出する（ワークブックでは特に<a class="reference internal" href="vqe.html"><span class="doc">変分法と変分量子固有値ソルバー法を学習する</span></a>以降）概念である「観測量の期待値」について説明します。</p>
<p>観測量とはそのまま「観測できる量」のことで、量子状態から取り出せる（古典的）情報のこととも言えます。例えば、何かしらの粒子の運動を量子力学的に記述した場合、その粒子の位置や運動量などが観測量です。</p>
<p>ケットで表される量子状態に対して、観測量はケットに作用する「エルミート演算子」で表現されます。細かい定義は参考文献に譲り、ここで必要な最小限のことだけ述べると、エルミート演算子は<strong>対角化可能で、実数の固有値を持つ</strong>という性質を持っています。つまり、<span class="math notranslate nohighlight">\(A\)</span>が<span class="math notranslate nohighlight">\(N\)</span>次元の量子状態の空間のエルミート演算子であれば、</p>
<div class="math notranslate nohighlight">
\[
A \ket{\phi_j} = a_j \ket{\phi_j}
\]</div>
<p>が成り立つような状態<span class="math notranslate nohighlight">\(\ket{\phi_j}\)</span>と実数<span class="math notranslate nohighlight">\(a_j\)</span>の組が<span class="math notranslate nohighlight">\(N\)</span>個存在し、各<span class="math notranslate nohighlight">\(\ket{\phi_j} \, (j=0,\dots,N-1)\)</span>は互いに直交します。このとき、<span class="math notranslate nohighlight">\(\ket{\phi_j}\)</span>を固有ベクトル、<span class="math notranslate nohighlight">\(a_j\)</span>を固有値と呼びます。そして、この固有値<span class="math notranslate nohighlight">\(a_j\)</span>が、演算子<span class="math notranslate nohighlight">\(A\)</span>で表される観測量の値に対応します<a class="footnote-reference brackets" href="#continuous-observables" id="id7">3</a>。</p>
<p>さて、<span class="math notranslate nohighlight">\(A\)</span>が<span class="math notranslate nohighlight">\(n\)</span>ビット量子レジスタに対する演算子であるとします。レジスタの状態<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>が<span class="math notranslate nohighlight">\(A\)</span>の固有ベクトルで</p>
<div class="math notranslate nohighlight">
\[
\ket{\psi} = \sum_{j=0}^{2^n-1} \gamma_j \ket{\phi_j}
\]</div>
<p>と分解されるとき、この状態を固有ベクトル基底<span class="math notranslate nohighlight">\(\{\ket{\phi_j}\}\)</span>で測定すると、状態<span class="math notranslate nohighlight">\(\ket{\phi_j}\)</span>が確率<span class="math notranslate nohighlight">\(|\gamma_j|^2\)</span>で得られます。そして、状態が<span class="math notranslate nohighlight">\(\ket{\phi_j}\)</span>であれば観測量<span class="math notranslate nohighlight">\(A\)</span>の値は<span class="math notranslate nohighlight">\(a_j\)</span>です。</p>
<p>そのような測定を多数回繰り返して<span class="math notranslate nohighlight">\(A\)</span>の値の期待値を求めることを考えます。期待値の定義は「確率変数のすべての値に確率の重みを付けた加重平均」です。<span class="math notranslate nohighlight">\(A\)</span>が確率分布<span class="math notranslate nohighlight">\(\{|\gamma|^2_j\}\)</span>に従って値<span class="math notranslate nohighlight">\(\{a_j\}\)</span>を取るので、</p>
<div class="math notranslate nohighlight">
\[
\bra{\psi} A \ket{\psi} = \sum_{j=0}^{2^n-1} a_j |\gamma_j|^2
\]</div>
<p>となります。ここから、量子コンピュータにおいて観測量の期待値を計算する方法を見出すことができます。具体的には、</p>
<ol class="simple">
<li><p>観測量をエルミート演算子で表現する</p></li>
<li><p>演算子を対角化し、固有値と対応する固有ベクトルを求める</p></li>
<li><p>固有ベクトルを基底として、レジスタの状態を測定する</p></li>
<li><p>測定から得られた確率分布を重みとして固有値の平均値を取る</p></li>
</ol>
<p>です。3の測定の際には、上のセクションで説明した測定基底の変換を利用します。</p>
</div>
<div class="section" id="chsh">
<h2><a class="toc-backref" href="#id14">CHSH不等式を見直す</a><a class="headerlink" href="#chsh" title="Permalink to this headline">¶</a></h2>
<p>実習の中で、</p>
<div class="math notranslate nohighlight">
\[
C = P_{00} - P_{01} - P_{10} + P_{11}
\]</div>
<p>という量を計算しました。ここで、<span class="math notranslate nohighlight">\(P_{lm}\)</span>は2つの量子ビットでそれぞれ<span class="math notranslate nohighlight">\(l, m \, (=0,1)\)</span>が得られる確率でした。実はこの量<span class="math notranslate nohighlight">\(C\)</span>は、2ビットレジスタにおけるある観測量の期待値として捉えることができます。</p>
<p>まず、1つの量子ビットに対して、固有値が<span class="math notranslate nohighlight">\(\pm 1\)</span>であるような観測量<span class="math notranslate nohighlight">\(\sigma^{\theta}\)</span>を考えます。そのような<span class="math notranslate nohighlight">\(\sigma^{\theta}\)</span>は無数に存在し、固有ベクトルで区別できます。<span class="math notranslate nohighlight">\(\theta\)</span>は固有ベクトルを決める何らかのパラメータです<a class="footnote-reference brackets" href="#specifying-eigenvectors" id="id8">4</a>。例えば<span class="math notranslate nohighlight">\(\sigma^0\)</span>という観測量を、計算基底を固有ベクトルとして、</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\sigma^0 \ket{0} = \ket{0} \\
\sigma^0 \ket{1} = -\ket{1}
\end{split}\]</div>
<p>で定義できる、という具合です。</p>
<p>次に、2つの量子ビットA, Bからなるレジスタを考え、<span class="math notranslate nohighlight">\(\sigma^{\kappa}\)</span>をAの、<span class="math notranslate nohighlight">\(\sigma^{\lambda}\)</span>をBの観測量とします。また、それぞれの演算子の固有ベクトルを</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\sigma^{\kappa} \ket{\kappa_{\pm}} = \pm \ket{\kappa_{\pm}} \\
\sigma^{\lambda} \ket{\lambda_{\pm}} = \pm \ket{\lambda_{\pm}}
\end{split}\]</div>
<p>で定義します。これらの固有ベクトルを使って、レジスタの状態<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>を</p>
<div class="math notranslate nohighlight">
\[
\ket{\psi} = c_{++} \ket{\lambda_+}_B \ket{\kappa_+}_A + c_{+-} \ket{\lambda_+}_B \ket{\kappa_-}_A + c_{-+} \ket{\lambda_-}_B \ket{\kappa_+}_A + c_{--} \ket{\lambda_-}_B \ket{\kappa_-}_A
\]</div>
<p>と分解します。ケットはAが右、Bが左になるよう並べました。すると、積<span class="math notranslate nohighlight">\(\sigma^{\lambda}_B \sigma^{\kappa}_A\)</span>の<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>に関する期待値は、</p>
<div class="math notranslate nohighlight">
\[
\bra{\psi} \sigma^{\lambda}_B \sigma^{\kappa}_A \ket{\psi} = |c_{++}|^2 - |c_{+-}|^2 - |c_{-+}|^2 + |c_{--}|^2
\]</div>
<p>です。</p>
<p>最後に、同じ結果を計算基底での測定で表すために、<span class="math notranslate nohighlight">\(\ket{\psi}\)</span>に対して基底変換を施します。<span class="math notranslate nohighlight">\(\{\ket{\kappa_{\pm}}, \ket{\lambda_{\pm}}\}\)</span>が何らかのパラメータ付きゲート<span class="math notranslate nohighlight">\(R(\theta)\)</span>を通して計算基底と</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\ket{\kappa_+} = R(\kappa) \ket{0} \\
\ket{\kappa_-} = R(\kappa) \ket{1} \\
\ket{\lambda_+} = R(\lambda) \ket{0} \\
\ket{\lambda_-} = R(\lambda) \ket{1}
\end{split}\]</div>
<p>で結びついているなら、状態<span class="math notranslate nohighlight">\(\ket{\psi'} = R^{-1}_B(\lambda) R^{-1}_A(\kappa) \ket{\psi}\)</span>を計算基底で測定したとき、</p>
<div class="math notranslate nohighlight">
\[\begin{split}
P_{00} = |c_{++}|^2 \\
P_{01} = |c_{+-}|^2 \\
P_{10} = |c_{-+}|^2 \\
P_{11} = |c_{--}|^2
\end{split}\]</div>
<p>が成り立ちます。確認のためはっきりさせておくと、左辺は<span class="math notranslate nohighlight">\(\ket{\psi'}\)</span>を計算基底で測定し、ビット列00, 01, 10, 11を得る確率です。つまり、最初の<span class="math notranslate nohighlight">\(C\)</span>は</p>
<div class="math notranslate nohighlight">
\[
C = \bra{\psi'} \sigma^0_B \sigma^0_A \ket{\psi'} = \bra{\psi} \sigma^{\lambda}_B \sigma^{\kappa}_A \ket{\psi}
\]</div>
<p>を表していたのでした。</p>
<p>これを踏まえて、CHSH不等式の左辺は結局何を計算していたのか、見直してみましょう。ここでベル状態を</p>
<div class="math notranslate nohighlight">
\[
\ket{\Psi} = \frac{1}{\sqrt{2}} \left(\ket{00} + \ket{11}\right)
\]</div>
<p>とおき、第0ビットをA、第1ビットをBとします。<span class="math notranslate nohighlight">\(R_y(\pi/4)\ket{0}, R_y(\pi/2)\ket{0}, R_y(3\pi/4)\ket{0}\)</span>が固有値<span class="math notranslate nohighlight">\(+1\)</span>の固有ベクトルとなるような演算子をそれぞれ<span class="math notranslate nohighlight">\(\sigma^{\pi/4}, \sigma^{\pi/2}, \sigma^{3\pi/4}\)</span>とすると、</p>
<div class="math notranslate nohighlight">
\[
S = C^0 - C^1 + C^2 + C^3 = \bra{\Psi} \sigma^{\pi/4}_B \sigma^0_A \ket{\Psi} - \bra{\Psi} \sigma^{3\pi/4}_B \sigma^0_A \ket{\Psi} + \bra{\Psi} \sigma^{\pi/4}_B \sigma^{\pi/2}_A \ket{\Psi} + \bra{\Psi} \sigma^{3\pi/4}_B \sigma^{\pi/2}_A \ket{\Psi}
\]</div>
<p>がわかります。</p>
<p>観測量<span class="math notranslate nohighlight">\(\sigma^{\theta}\)</span>を用いてCHSH不等式をより正確に表現すると、</p>
<blockquote>
<div><p>4つのパラメータ<span class="math notranslate nohighlight">\(\kappa, \lambda, \mu, \nu\)</span>を用いて<br />
<span class="math notranslate nohighlight">\(S(\kappa, \lambda, \mu, \nu) = \langle \sigma^{\kappa}\sigma^{\lambda} \rangle - \langle \sigma^{\kappa}\sigma^{\nu} \rangle + \langle \sigma^{\mu}\sigma^{\lambda} \rangle + \langle \sigma^{\mu}\sigma^{\nu} \rangle\)</span><br />
という量を定義すると、エンタングルメントのない古典力学において<span class="math notranslate nohighlight">\(|S| \leq 2\)</span>である</p>
</div></blockquote>
<p>となります。</p>
<p>実習で用いた<span class="math notranslate nohighlight">\(\sigma^{\theta}\)</span>のパラメータは、<span class="math notranslate nohighlight">\(|S|\)</span>の値を最大化するものでした。次のセルで数値的にこのことを確かめています。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">quantum_S</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Three-parameter function to be minimized. Returns -|S| = -|&lt;sigma^k sigma^l&gt; - &lt;sigma^k sigma^n&gt; + &lt;sigma^m sigma^l&gt; + &lt;sigma^m sigma^n&gt;| with k fixed to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Initial values</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">])</span>
<span class="c1"># Bounds on all parameters ([0, pi])</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">([</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1"># Minimize using scipy.optimize.minimize</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">quantum_S</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;argmax |S|: kappa=0, lambda=</span><span class="si">{:.2f}</span><span class="s1">pi, mu=</span><span class="si">{:.2f}</span><span class="s1">pi, nu=</span><span class="si">{:.2f}</span><span class="s1">pi&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id15">問題: ベル状態と可分状態の違い</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sigma">
<h3><a class="toc-backref" href="#id16">一般の<span class="math notranslate nohighlight">\(\sigma\)</span>演算子の期待値</a><a class="headerlink" href="#sigma" title="Permalink to this headline">¶</a></h3>
<p>上のように<span class="math notranslate nohighlight">\(R_y(\theta)\ket{0}\)</span>が固有値<span class="math notranslate nohighlight">\(+1\)</span>の固有ベクトルとなるような演算子を<span class="math notranslate nohighlight">\(\sigma^{\theta}\)</span>として、<span class="math notranslate nohighlight">\(\bra{\Psi} \sigma^{\phi}_B \sigma^{\theta}_A \ket{\Psi}\)</span>を計算してみましょう。まず基底変換を具体的に書き下します。</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\ket{\Psi'} &amp; = R_{y,B}(-\phi) R_{y,A}(-\theta) \frac{1}{\sqrt{2}} \left( \ket{00} + \ket{11} \right) \\
&amp; = \frac{1}{\sqrt{2}} \left\{ \left[ \cos\left(\frac{\phi}{2}\right)\ket{0} - \sin\left(\frac{\phi}{2}\right)\ket{1} \right] \left[ \cos\left(\frac{\theta}{2}\right)\ket{0} - \sin\left(\frac{\theta}{2}\right)\ket{1} \right] + \left[ \sin\left(\frac{\phi}{2}\right)\ket{0} + \cos\left(\frac{\phi}{2}\right)\ket{1} \right] \left[ \sin\left(\frac{\theta}{2}\right)\ket{0} + \cos\left(\frac{\theta}{2}\right)\ket{1} \right] \right\} \\
&amp; = \frac{1}{\sqrt{2}} \left[ \cos\left(\frac{\theta - \phi}{2}\right)\ket{00} - \sin\left(\frac{\theta - \phi}{2}\right)\ket{01} + \sin\left(\frac{\theta - \phi}{2}\right)\ket{10} + \cos\left(\frac{\theta - \phi}{2}\right)\ket{11} \right].
\end{align}
\end{split}\]</div>
<p>したがって、</p>
<div class="math notranslate nohighlight" id="equation-quantum-correlation">
<span class="eqno">(2)<a class="headerlink" href="#equation-quantum-correlation" title="Permalink to this equation">¶</a></span>\[\begin{split}\begin{align}
\bra{\Psi} \sigma^{\phi}_B \sigma^{\theta}_A \ket{\Psi} &amp; = \bra{\Psi'} \sigma^{0}_B \sigma^{0}_A \ket{\Psi'} \\
&amp; = \cos^2\left(\frac{\theta - \phi}{2}\right) - \sin^2\left(\frac{\theta - \phi}{2}\right) \\
&amp; = \cos(\theta - \phi)
\end{align}\end{split}\]</div>
<p>となります。</p>
</div>
<div class="section" id="id10">
<h3><a class="toc-backref" href="#id17">問題</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>上の計算結果を量子回路でも確認してみましょう。実習のように2ビット量子レジスタをベル状態にし、2つの量子ビットに適当な<span class="math notranslate nohighlight">\(R_y\)</span>ゲートをかけ、期待値<span class="math notranslate nohighlight">\(C\)</span>を<span class="math notranslate nohighlight">\(R_y\)</span>ゲートのパラメータの値の差の関数としてプロットします。</p>
<div class="cell tag_raises-exception tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define theta and phi values</span>
<span class="n">thetas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span>
<span class="n">theta_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\pi/4$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\pi/2$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$3\pi/4$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\pi$&#39;</span><span class="p">]</span>
<span class="n">phis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Construct a circuit for each (theta, phi) pair</span>
<span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">itheta</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iphi</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phis</span><span class="p">):</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;circuit_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">itheta</span><span class="p">,</span> <span class="n">iphi</span><span class="p">))</span>

        <span class="c1">##################</span>
        <span class="c1">### EDIT BELOW ###</span>
        <span class="c1">##################</span>

        <span class="c1">#circuit.?</span>
        
        <span class="c1">##################</span>
        <span class="c1">### EDIT ABOVE ###</span>
        <span class="c1">##################</span>
        
        <span class="n">circuit</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>

<span class="c1"># Execute the circuit in qasm_simulator and retrieve the results</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">sim_job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">simulator</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sim_job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="c1"># Plot C versus (theta - phi) for each theta</span>
<span class="n">icirc</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">itheta</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">phis</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">iphi</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phis</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="n">icirc</span><span class="p">])</span>

        <span class="c1">##################</span>
        <span class="c1">### EDIT BELOW ###</span>
        <span class="c1">##################</span>

        <span class="c1">#y[iphi] = ?</span>
        
        <span class="c1">##################</span>
        <span class="c1">### EDIT ABOVE ###</span>
        <span class="c1">##################</span>

        <span class="n">icirc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">theta_labels</span><span class="p">[</span><span class="n">itheta</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\theta - \phi$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle \Psi | \sigma^{\phi}_B \sigma^{\theta}_A | \Psi \rangle$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>式<a class="reference internal" href="#equation-quantum-correlation">(2)</a>では、2体系の期待値がパラメータ<span class="math notranslate nohighlight">\(\theta\)</span>と<span class="math notranslate nohighlight">\(\phi\)</span>だけを含む関数の積として記述できないことがはっきり示されています。これはベル状態の持つエンタングルメントの現れで、2体系をバラバラに考えることができないということを言っています。</p>
<p>それでは、<span class="math notranslate nohighlight">\(C\)</span>や<span class="math notranslate nohighlight">\(S\)</span>をエンタングルメントのない状態（可分状態）に対して計算してみたら、何が得られるでしょうか。例えば、ベル状態<span class="math notranslate nohighlight">\(1/\sqrt{2}(\ket{00} + \ket{11})\)</span>の代わりに、「確率1/2で<span class="math notranslate nohighlight">\(\ket{00}\)</span>、確率1/2で<span class="math notranslate nohighlight">\(\ket{11}\)</span>」という状態を考えます。</p>
<p>まずは<span class="math notranslate nohighlight">\(|S(\kappa, \lambda, \mu, \nu)|\)</span>の最大値を求めます。</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">classical_S</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Four-parameter function to be minimized. Returns -|S| = -|&lt;sigma^k sigma^l&gt; - &lt;sigma^k sigma^n&gt; + &lt;sigma^m sigma^l&gt; + &lt;sigma^m sigma^n&gt;|.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        params (np.ndarray): Values of kappa, lambda, mu, nu</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        float: -|S|</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">params</span>
    
    <span class="n">S</span> <span class="o">=</span> <span class="mf">0.</span>
    
    <span class="c1"># S from |00&gt;</span>
    <span class="c1">##################</span>
    <span class="c1">### EDIT BELOW ###</span>
    <span class="c1">##################</span>
    <span class="c1">#sksl_00 = </span>
    <span class="c1">#sksn_00 = </span>
    <span class="c1">#smsl_00 = </span>
    <span class="c1">#smsn_00 = </span>
    <span class="c1">#S += (sksl_00 - sksn_00 + smsl_00 + smsn_00) * 0.5</span>
    <span class="c1">##################</span>
    <span class="c1">### EDIT ABOVE ###</span>
    <span class="c1">##################</span>
    
    <span class="c1"># S from |11&gt;</span>
    <span class="c1">##################</span>
    <span class="c1">### EDIT BELOW ###</span>
    <span class="c1">##################</span>
    <span class="c1">#sksl_11 = </span>
    <span class="c1">#sksn_11 = </span>
    <span class="c1">#smsl_11 = </span>
    <span class="c1">#smsn_11 = </span>
    <span class="c1">#S += (sksl_11 - sksn_11 + smsl_11 + smsn_11) * 0.5</span>
    <span class="c1">##################</span>
    <span class="c1">### EDIT ABOVE ###</span>
    <span class="c1">##################</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

<span class="c1"># Initial values</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">])</span>
<span class="c1"># Bounds on all parameters ([0, pi])</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">([</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1"># Minimize using scipy.optimize.minimize</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">classical_S</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;argmax |S|: kappa=</span><span class="si">{:.3f}</span><span class="s1">pi, lambda=</span><span class="si">{:.3f}</span><span class="s1">pi, mu=</span><span class="si">{:.3f}</span><span class="s1">pi, nu=</span><span class="si">{:.3f}</span><span class="s1">pi&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;max |S|:&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">res</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>この状態を量子回路で実装して、上の実験を繰り返してみましょう。ただし、実際に確率1/2で異なる状態が現れるような「混合状態」は量子回路では表現しにくいので、<span class="math notranslate nohighlight">\(\ket{00}\)</span>と<span class="math notranslate nohighlight">\(\ket{11}\)</span>を初期状態とする回路を一つずつ用意して、それらから得る<span class="math notranslate nohighlight">\(C\)</span>の平均値を求めることにします。</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Construct a circuit for each (theta, phi) pair</span>
<span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">itheta</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">iphi</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phis</span><span class="p">):</span>
        <span class="n">circuit_00</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;circuit_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_00&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">itheta</span><span class="p">,</span> <span class="n">iphi</span><span class="p">))</span>
        <span class="n">circuit_11</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;circuit_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_11&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">itheta</span><span class="p">,</span> <span class="n">iphi</span><span class="p">))</span>

        <span class="c1">##################</span>
        <span class="c1">### EDIT BELOW ###</span>
        <span class="c1">##################</span>

        <span class="c1">#circuit_00.?</span>
        <span class="c1">#circuit_11.?</span>
        
        <span class="c1">##################</span>
        <span class="c1">### EDIT ABOVE ###</span>
        <span class="c1">##################</span>
        
        <span class="n">circuit_00</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
        <span class="n">circuit_11</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circuit_00</span><span class="p">)</span>
        <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">circuit_11</span><span class="p">)</span>

<span class="c1"># Execute the circuit in qasm_simulator and retrieve the results</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">sim_job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">simulator</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sim_job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="c1"># Plot C versus (theta - phi) for each theta</span>
<span class="n">icirc</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">itheta</span><span class="p">,</span> <span class="n">theta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thetas</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">phis</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">iphi</span><span class="p">,</span> <span class="n">phi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phis</span><span class="p">):</span>
        <span class="n">c_00</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="n">icirc</span><span class="p">])</span>
        <span class="n">c_11</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="n">icirc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1">##################</span>
        <span class="c1">### EDIT BELOW ###</span>
        <span class="c1">##################</span>

        <span class="c1">#y[iphi] = ?</span>
        
        <span class="c1">##################</span>
        <span class="c1">### EDIT ABOVE ###</span>
        <span class="c1">##################</span>

        <span class="n">icirc</span> <span class="o">+=</span> <span class="mi">2</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">theta_labels</span><span class="p">[</span><span class="n">itheta</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\theta - \phi$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\langle \Psi | \sigma^{\theta}_A \sigma^{\phi}_B | \Psi \rangle$&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>ベル状態からの結果と比べてみて、何が言えるでしょうか。</p>
<p><strong>提出するもの</strong></p>
<ul class="simple">
<li><p>完成した回路のコード（EDIT BELOW / EDIT ABOVEの間を埋める）とシミュレーション結果によるプロット</p></li>
<li><p>ベル状態と可分状態の混合状態とでの2体相関の違いに関する考察</p></li>
</ul>
<dl class="footnote brackets">
<dt class="label" id="simulator-noise"><span class="brackets"><a class="fn-backref" href="#id3">1</a></span></dt>
<dd><p>標準設定において。実機の振る舞いに従うよう、あえてノイズを加えるような設定も存在します。</p>
</dd>
<dt class="label" id="orthogonal"><span class="brackets"><a class="fn-backref" href="#id5">2</a></span></dt>
<dd><p>ここまで状態ケットの内積に関する説明をしていませんが、線形代数に慣れている方は「量子力学の状態ケットはヒルベルト空間の要素である」と理解してください。慣れていない方は、量子ビットの直行する状態とは<span class="math notranslate nohighlight">\(\ket{0}\)</span>と<span class="math notranslate nohighlight">\(\ket{1}\)</span>に同じゲートをかけて得られる状態のことを言うと覚えておいてください。</p>
</dd>
<dt class="label" id="continuous-observables"><span class="brackets"><a class="fn-backref" href="#id7">3</a></span></dt>
<dd><p>上で粒子の位置や運動量という例を挙げたので、<span class="math notranslate nohighlight">\(a_j \, (j=0,\dots,N-1)\)</span>と離散的な固有値が観測量の値だというと混乱するかもしれません。位置や運動量といった連続的な値を持つ観測量は、無数に固有値を持つエルミート演算子で表されます。そのような演算子のかかる状態空間は無限次元です。</p>
</dd>
<dt class="label" id="specifying-eigenvectors"><span class="brackets"><a class="fn-backref" href="#id8">4</a></span></dt>
<dd><p>量子ビットの一般の状態は実パラメータ2つで決まるので、<span class="math notranslate nohighlight">\(\sigma^{\theta, \phi}\)</span>などと書いたほうがより明示的ですが、ここでの議論では結局1パラメータしか使わないので、「何か一般の（次元を指定しない）パラメータ」として<span class="math notranslate nohighlight">\(\theta\)</span>と置いています。</p>
</dd>
</dl>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "UTokyo-ICEPP/qc-workbook",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="chsh_inequality.html" title="previous page">CHSH不等式の破れを確認する</a>
    <a class='right-next' id="next-link" href="circuit_from_scratch.html" title="next page">単純な量子回路をゼロから書く</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By 東京大学素粒子物理国際研究センター<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>